#!/usr/bin/env ruby

require 'pry'
require 'json'

begin
  require 'google_drive'
rescue LoadError
  abort "You need to install the google_drive gem first."
end

CREDENTIALS_FILE_PATH = File.expand_path('~/.gdrive.json')

unless File.file?(CREDENTIALS_FILE_PATH)
  # This has to be a file, so it can be updated with scope and refresh token (automatically).
  File.open(CREDENTIALS_FILE_PATH, 'w') do |file|
    file.puts({
  client_id: ENV.fetch('GDRIVE_CLIENT_ID'),
  client_secret: ENV.fetch('GDRIVE_CLIENT_SECRET')
}.to_json)
  end
end

# Creates a session. This will prompt the credential via command line for the
# first time and save it to config.json file for later usages.
# See this document to learn how to create config.json:
# https://github.com/gimite/google-drive-ruby/blob/master/doc/authorization.md
session = GoogleDrive::Session.from_config(CREDENTIALS_FILE_PATH)

def download(session, remote_path, local_path)
  file = find_file(session, remote_path)
  file || abort("File #{remote_path} not found")
  if file.is_a?(GoogleDrive::Collection)
    Dir.mkdir(local_path)
    file.files.each do |file|
      require 'pry'; binding.pry ###
      # download(session, )
    end
  else
    file.download_to_file(local_path)
  end
rescue NotImplementedError
  # This will want the format to be specified most likely.
  #
  # file.export_as_file(local_path)
  binding.pry
end

def find_file(session, full_path)
  full_path.split('/').reduce(session.root_collection) do |parent, file_name|
    parent.file_by_title(file_name)
  end
end

case ARGV.shift
when 'list', 'ls'
  collection = ARGV.first.nil? || ARGV.first == '/' ? session.root_collection : find_file(session, ARGV.first)
  collection.files.uniq(&:title).sort_by(&:title).each do |file|
    puts file.is_a?(GoogleDrive::Collection) ? "#{`tput setaf 4`}#{file.title}#{`tput sgr0`}" : file.title
  end
# when 'search'
#   drive_service = session.instance_variable_get(:@fetcher).drive
#   query = "title contains '#{ARGV.first}'"
#   puts "Query: #{query}"
#   files = drive_service.list_files(q: query)
#   files.items.each do |file|
#     puts file.title
#   end
when 'download'
  remote_path, local_path = ARGV
  local_path ||= File.basename(remote_path)
  puts "~ Downloading '#{remote_path}' to #{local_path}"
  download(session, remote_path, local_path)
when 'upload'
  local_path, remote_path = ARGV
  remote_path ||= "/#{File.basename(local_path)}"
  puts "~ Uploading '#{local_path}' to #{remote_path}"
  session.upload_from_file(local_path, remote_path, convert: false)
when 'remove', 'rm'
  puts "~ Deleting '#{ARGV.first}'"
  file = session.file_by_title(ARGV.first)
  file.delete
else
  puts eval("\"#{DATA.read}\"")
end

__END__
#{`tput setaf 9`}Usage:#{`tput sgr0`}

#{`tput setaf 10`}#{File.basename($0)} ls [path]#{`tput sgr0`} List given path. If no path is given, root is assummed.

#{`tput setaf 11`}#{File.basename($0)} download [path]#{`tput sgr0`} Download file.
#{`tput setaf 11`}#{File.basename($0)} upload [local path] [remote path]#{`tput sgr0`} Upload file into a remote path.

#{`tput setaf 9`}#{File.basename($0)} remove [remote path]#{`tput sgr0`} Delete remote file.
